import { default as ImageLayer } from 'https://esm.run/ol@6.9.0/src/layer/Image';
import { default as ImageWMS } from 'https://esm.run/ol@6.9.0/src/source/ImageWMS';
import { default as TileLayer } from 'https://esm.run/ol@6.9.0/src/layer/Tile';
import { default as WMTS } from 'https://esm.run/ol@6.9.0/src/source/WMTS';
import { default as WMTSTileGrid } from 'https://esm.run/ol@6.9.0/src/tilegrid/WMTS';
import { get as getProjection } from 'https://esm.run/ol@6.9.0/src/proj';
import { getTopLeft, getWidth } from 'https://esm.run/ol@6.9.0/src/extent';
import { Circle as CircleStyle, Fill, Stroke, Style, Text, Icon } from 'https://esm.run/ol@6.9.0/src/style';
import { default as Map } from 'https://esm.run/ol@6.9.0/src/Map';
import GeoJSON from 'https://esm.run/ol@6.9.0/src/format/GeoJSON';
import { default as VectorSource } from 'https://esm.run/ol@6.9.0/src/source/Vector';
import { default as VectorLayer } from 'https://esm.run/ol@6.9.0/src/layer/Vector';
import { map } from './index.js';

const COLORS = {
    "black": [0, 0, 0],
    "silver": [192, 192, 192],
    "gray": [128, 128, 128],
    "white": [255, 255, 255],
    "maroon": [128, 0, 0],
    "red": [255, 0, 0],
    "purple": [128, 0, 128],
    "fuchsia": [255, 0, 255],
    "green": [0, 128, 0],
    "lime": [0, 255, 0],
    "olive": [128, 128, 0],
    "yellow": [255, 255, 0],
    "navy": [0, 0, 128],
    "blue": [0, 0, 255],
    "teal": [0, 128, 128],
    "aqua": [0, 255, 255]
}

function lineStyle (color) {
    let colorString = `rgb(${color[0]},${color[1]},${color[2]})`
    return {
        stroke: new Stroke({
            color: colorString,
            width: 1,
        }),
    }
}

function pointStyle (color, hexColor, icon = "") {
    let colorString = `rgb(${color[0]},${color[1]},${color[2]})`
    // replace 2nd occurence - first path occurence is for white bg halo - https://stackoverflow.com/a/44568739
    // TOOD: maybe replace to generator code
    let i = 0
    icon = icon.replace(/<path/g, match => ++i === 2 ? `<path fill="#${hexColor}"` : match)
    const src = 'data:image/svg+xml;utf8,' + escape(icon)
    return {
        image: new Icon({
            opacity: 1,
            src: src,
            scale: 1.5,
        })
    }
}

function polygonStyle (color) {
    // TODO: fix default colors in generator code
    let colorString = `rgb(${color[0]},${color[1]},${color[2]})`
    let fillColor = `rgba(${color[0]},${color[1]},${color[2]},0.2)`
    return {
        stroke: new Stroke({
            color: colorString,
            lineDash: [4],
            width: 2,
        }),
        fill: new Fill({
            color: fillColor,
        }),
    }
}


function getStyle (config) {
    const styles = {
        'Point': pointStyle,
        'LineString': lineStyle,
        'Polygon': polygonStyle,
    };
    let style = styles[config.geomType]
    let color = config.color
    if (color.split(',').length > 2) {
        color = color.split(',')
    }
    if (config.geomType === "Point" && "svgIcon" in config) {
        return style(color, config.hexColor, config.svgIcon)
    }
    return style(color)
}


function getStyleFunction (config) {
    return function (feature, resolution) {
        let symbolStyle = getStyle(config)
        if ("labels" in config && config.labels) {
            const placementDic = {
                "Point": {
                    offsetX: 7,
                    offsetY: -7,
                    textAlign: 'start',
                    overflow: true
                },
                "Polygon": {
                    textAlign: 'center',
                    overflow: true
                },
                "LineString": {
                    offsetX: 6,
                    offsetY: -6,
                    textAlign: 'start',
                }
            }
            let textStyle = {
                text: new Text(
                    {
                        ...{
                            text: feature.get(config.labelProperty),
                            scale: 1.3,
                            fill: new Fill({
                                color: '#000000'
                            }),
                            stroke: new Stroke({
                                color: 'rgba(255, 255, 255, 0.8)',
                                width: 3
                            })
                        },
                        ...placementDic[config.geomType]
                    }
                )
            }
            return new Style(
                {
                    ...textStyle,
                    ...symbolStyle
                }
            )
        }
        return new Style(symbolStyle)
    }
}

const projection = getProjection('EPSG:3857');
const projectionExtent = projection.getExtent();
const size = getWidth(projectionExtent) / 256;
const resolutions = new Array(19);
const matrixIds = new Array(19);
for (let z = 0; z < 19; ++z) {
    // generate resolutions and matrixIds arrays for this WMTS
    resolutions[z] = size / Math.pow(2, z);
    matrixIds[z] = z;
}

const layers = [];

{{ #layers}}
layers.push({{{layer_renderer}}})
{{/layers}}

let ftLayerConfig = {}
{{#featureLayers}}
ftLayerConfig = {}
{{#labels}}
ftLayerConfig = {...ftLayerConfig, ...{"labels": {{ labels }}, "labelProperty": '{{ labelProperty }}'}}
{{/labels}}
{{#icon}}
ftLayerConfig = {...ftLayerConfig, ...{"svgIcon": '{{{ svgIcon }}}'}}
{{/icon}}
ftLayerConfig = {...ftLayerConfig, ...{"color": '{{ color }}', "hexColor": '{{ hexColor }}', "geomType": '{{ geomType }}'}}
layers.push(new VectorLayer({
    declutter: true,
    source: new VectorSource({
        features: new GeoJSON({ featureProjection: 'EPSG:3857'}).readFeatures(
            '{{{ source }}}'
        ),
    }),
    style: getStyleFunction(
            ftLayerConfig
    ),
    {{ #opacity}}
    opacity: {{ opacity }},
    {{ /opacity }}
}))
{{/featureLayers}}

map.setTarget(document.getElementById('map'))
map.setLayers(layers)
// promise returning viewOptions is expected instead of View object https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html#setView

{{#location}}
let viewConfig = {
    center: [{{ x }}, {{ y }}],
    zoom: {{ z }},
}
{{/location}}
{{^location }} //default location
let viewConfig = {
    center: [564457.4160, 6783258.6045],
    zoom: 7,
}
{{/location}}

const viewOptions = new Promise((resolve, reject) => {
    resolve(
        viewConfig
    );
});
map.setView(viewOptions)

{{#constrainBoundsEnabled }}
map.once('postrender', function(event) {   
    setTimeout(() => {
        let mapExtent = map.getView().calculateExtent(map.getSize())
        
        viewConfig.extent = mapExtent
        const viewOptions = new Promise((resolve, reject) => {
            resolve(
                viewConfig
            );
        });
        map.setView(viewOptions)
    }, 10);
});
{{/constrainBoundsEnabled }}

function postRender (evt) {
    evt.context.globalCompositeOperation = 'color'
    if (evt.context.globalCompositeOperation === 'color') {
        // operation is supported by browser
        evt.context.fillStyle = 'rgba(255,255,255,' + 1 + ')'
        evt.context.fillRect(
            0,
            0,
            evt.context.canvas.width,
            evt.context.canvas.height
        )
    }
    evt.context.globalCompositeOperation = 'source-over'
}

map
    .getLayers().forEach(function (lyr) {

        if (lyr.get('grayscale')) {
            // see comment on this answer https://stackoverflow.com/a/59819793
            lyr.on('postrender', postRender)
        }
    }
    )

export { map }
