import { default as ImageLayer } from 'https://esm.run/ol@6.9.0/src/layer/Image';
import { default as ImageWMS } from 'https://esm.run/ol@6.9.0/src/source/ImageWMS';
import { default as TileLayer } from 'https://esm.run/ol@6.9.0/src/layer/Tile';
import { default as WMTS } from 'https://esm.run/ol@6.9.0/src/source/WMTS';
import { default as WMTSTileGrid } from 'https://esm.run/ol@6.9.0/src/tilegrid/WMTS';
import { get as getProjection } from 'https://esm.run/ol@6.9.0/src/proj';
import { getTopLeft, getWidth } from 'https://esm.run/ol@6.9.0/src/extent';
import { Circle as CircleStyle, Fill, Stroke, Style, Text, Icon } from 'https://esm.run/ol@6.9.0/src/style';
import { default as Map } from 'https://esm.run/ol@6.9.0/src/Map';
import GeoJSON from 'https://esm.run/ol@6.9.0/src/format/GeoJSON';
import { default as VectorSource } from 'https://esm.run/ol@6.9.0/src/source/Vector';
import { default as VectorLayer } from 'https://esm.run/ol@6.9.0/src/layer/Vector';
import 'https://esm.run/mustache@4.2.0/mustache.js';

let config={{{ config }}}

var map
if (config.generator){
    console.log("generator", config)
    this.$refs["map-root"].innerHTML =''
    map = new Map({
    target: this.$refs["map-root"],
    })
}else{
    map = new Map({
    target: "map"
    })
}

function lineStyle(config) {
    let colorString = `rgb(${config.color[0]},${config.color[1]},${config.color[2]})`;
    let dash = getDash(config);
    return {
    stroke: new Stroke({
        ...{
        color: colorString,
        width: config.width,
        },
        ...dash,
    }),
    };
}

function pointStyle(config) {
    // replace 2nd occurence in SVG - first path occurence is for white bg halo - https://stackoverflow.com/a/44568739
    // TOOD: maybe move to generator code
    let scale = 1.5;
    if ("iconSize" in config) {
    scale = config.iconSize;
    }
    let i = 0;
    let icon = config.svgIcon.replace(/<path/g, (match) =>
    ++i === 2 ? `<path fill="#${config.hexColor}"` : match
    );
    const src = "data:image/svg+xml;utf8," + escape(icon);
    return {
    image: new Icon({
        opacity: 1,
        src: src,
        scale: scale,
    }),
    };
}

function getDash(config) {
    const dashDic = {
    dashed: {
        lineDash: [4],
    },
    solid: {},
    dotted: {
        lineDash: [1, 4, 1, 4],
    },
    "dash-dotted": {
        lineDash: [9, 3, 3, 3],
    },
    };
    let dash;
    if (!Array.isArray(config.stroke)) {
    dash =
        config.stroke in dashDic
        ? dashDic[config.stroke]
        : dashDic["solid"];
    } else {
    dash = {
        lineDash: config.stroke,
    };
    }
    return dash;
}

function polygonStyle(config) {
    // TODO: fix default colors in generator code
    let colorString = `rgb(${config.color[0]},${config.color[1]},${config.color[2]})`;
    let fillColor = `rgba(${config.color[0]},${config.color[1]},${config.color[2]},0.2)`;
    if (!("stroke" in config)) {
    config.stroke = "dashed";
    }
    if (!("width" in config)) {
    config.width = 2;
    }
    let dash = getDash(config);
    return {
    stroke: new Stroke({
        ...{
        color: colorString,
        width: config.width,
        },
        ...dash,
    }),
    fill: new Fill({
        color: fillColor,
    }),
    };
}

function getStyle(config) {
    console.log(config.geomType)
    const styles = {
    Point: pointStyle,
    LineString: lineStyle,
    Polygon: polygonStyle,
    };
    let style = styles[config.geomType];
    if (
    typeof config.color === "string" &&
    config.color.split(",").length > 2
    ) {
    config.color = config.color.split(",");
    }
    return style(config);
}

function getStyleFunction(config) {
    // eslint-disable-next-line no-unused-vars
    return function (feature, resolution) {
    let symbolStyle = getStyle(config);
    if ("labels" in config && config.labels) {
        const placementDic = {
        Point: {
            offsetX: 7,
            offsetY: -7,
            textAlign: "start",
            overflow: true,
        },
        Polygon: {
            textAlign: "center",
            overflow: true,
        },
        LineString: {
            offsetX: 6,
            offsetY: -6,
            textAlign: "start",
        },
        };
        let textStyle = {
        text: new Text({
            ...{
            text: feature.get(config.labelProperty),
            scale: 1.3,
            fill: new Fill({
                color: "#000000",
            }),
            stroke: new Stroke({
                color: "rgba(255, 255, 255, 0.8)",
                width: 3,
            }),
            },
            ...placementDic[config.geomType],
        }),
        };
        return new Style({
        ...textStyle,
        ...symbolStyle,
        });
    }
    return new Style(symbolStyle);
    };
}

function isValidHttpUrl(string) {
    let url;
    try {
    url = new URL(string);
    } catch (_) {
    return false;
    }

    return url.protocol === "http:" || url.protocol === "https:";
}

const projection = getProjection("EPSG:3857");
const projectionExtent = projection.getExtent();
const size = getWidth(projectionExtent) / 256;
const resolutions = new Array(19);
const matrixIds = new Array(19);
for (let z = 0; z < 19; ++z) {
    // generate resolutions and matrixIds arrays for this WMTS
    resolutions[z] = size / Math.pow(2, z);
    matrixIds[z] = z;
}

async function getResourceText(filename) {
    let response = await fetch(filename);
    if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.text();
}
// eslint-disable-next-line no-unused-vars
async function getFeatureData(config) {
    if (config.layerType === "featureLayer") {
    let ftCollection;
    if (isValidHttpUrl(config.source)) {
        let ftCollectionString = await getResourceText(config.source);
        ftCollection = JSON.parse(ftCollectionString);
    } else {
        ftCollection = config.source;
    }
    return { ftCollection: ftCollection, config: config };
    } else {
    // optionally retrieve metadata from service
    return { serviceUrl: config.serviceUrl, config: config };
    }
}

function postRender(evt) {
    let grayscale = evt.target.get("grayscale");
    evt.context.globalCompositeOperation = "color";
    if (evt.context.globalCompositeOperation === "color") {
    // operation is supported by browser
    evt.context.fillStyle = "rgba(255,255,255," + grayscale + ")";
    evt.context.fillRect(
        0,
        0,
        evt.context.canvas.width,
        evt.context.canvas.height
    );
    }
    evt.context.globalCompositeOperation = "source-over";
}

const promises = [];

if (!config.generator){
    // REMOVE THIS IF BLOCK IN VUEJS APP WHEN COPYING OVER CODE ONLY KEEP ELSE
    {{ #layersString}}
    promises.push(
        getFeatureData(
            {{{.}}}    
        )
    )
    {{/layersString}}
}else{
    config.layersString = config.layers.map(x=> JSON.stringify(x))
    let template = `
    {{ #layersString}}
    promises.push(
        getFeatureData(
            {{{.}}}    
        )
    )
    {{/layersString}}`;
    let promisesJS = Mustache.render(template, config);
    eval(promisesJS);
}


const layers = [];
// resolve promises with all to maintain layer order
Promise.all(promises).then((values) => {
    values.forEach((result) => {
    if (result.config.layerType === "featureLayer") {
        layers.push(
        new VectorLayer({
            declutter: true,
            source: new VectorSource({
            features: new GeoJSON({
                featureProjection: "EPSG:3857",
            }).readFeatures(result.ftCollection),
            }),
            style: getStyleFunction(result.config),
            opacity: result.config.opacity,
        })
        );
    } else if (result.config.layerType === "serviceLayer") {
        if (result.config.serviceType === "WMS") {
        layers.push(
            new ImageLayer({
            source: new ImageWMS({
                url: result.config.serviceUrl,
                params: { LAYERS: result.config.layerName }, // TODO: add style parameter
                ratio: 1,
            }),
            ...("grayscale" in result.config && {
                grayscale: result.config.grayscale,
            }), // add property conditionally
            ...("opacity" in result.config && {
                opacity: result.config.opacity,
            }),
            })
        );
        } else if (result.config.serviceType === "WMTS") {
        layers.push(
            new TileLayer({
            source: new WMTS({
                url: result.config.serviceUrl,
                layer: result.config.layerName,
                matrixSet: "EPSG:3857",
                format: "image/png",
                projection: projection,
                tileGrid: new WMTSTileGrid({
                origin: getTopLeft(projectionExtent),
                resolutions: resolutions,
                matrixIds: matrixIds,
                }),
                style: "default",
                wrapX: true,
            }),
            ...("grayscale" in result.config && {
                grayscale: result.config.grayscale,
            }), // add property conditionally
            ...("opacity" in result.config && {
                opacity: result.config.opacity,
            }),
            })
        );
        }
    }
    });
    map.setLayers(layers);
    map.getLayers().forEach((lyr) => {
    let grayscale = lyr.get("grayscale");
    if (grayscale > 0) {
        lyr.on("postrender", postRender);
    }
    });
    map.render()
    // TODO: improve; assuming this executes after end of this function, might be race condition
    if (config.generator){
        this.map = map
        this.map.on('moveend', () => {
            this.updateMapState()
        })
    }
});
// promise returning viewOptions is expected instead of View object https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html#setView
let viewConfigTemplate = `
{{#location}}
{
    "center": [{{ x }}, {{ y }}],
    "zoom": {{ z }}
}
{{/location}}
{{^location }}
{
    "center": [564457.4160, 6783258.6045],
    "zoom": 7
}
{{/location}}`;
let viewConfig = JSON.parse(Mustache.render(viewConfigTemplate, config))
// eslint-disable-next-line no-unused-vars
const viewOptions = new Promise((resolve, reject) => {
    resolve( viewConfig );
});

let constrainBoundsTemplate = 
`{{#constrainBoundsEnabled }}
map.once('postrender', function(event) {   
    setTimeout(() => {
        let mapExtent = map.getView().calculateExtent(map.getSize())
        
        viewConfig.extent = mapExtent
        const viewOptions = new Promise((resolve, reject) => {
            resolve(
                viewConfig
            );
        });
        map.setView(viewOptions)
    }, 10);
});
{{/constrainBoundsEnabled }}`
let constrainSet = Mustache.render(constrainBoundsTemplate, config)
eval(constrainSet)
map.setView(viewOptions);



