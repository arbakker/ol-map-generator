{{{imports}}}

function lineStyle (config) {
    let colorString = `rgb(${config.color[0]},${config.color[1]},${config.color[2]})`
    let dash = getDash(config)
    return {
        stroke: new Stroke(
            {
                ...{
                    color: colorString,
                    width: config.width,
                },
                ...dash
            }
     )
    }
}

function pointStyle (config) {
    // replace 2nd occurence in SVG - first path occurence is for white bg halo - https://stackoverflow.com/a/44568739
    // TOOD: maybe move to generator code
    let scale = 1.5
    if ('iconSize' in config){
        scale = config.iconSize
    }
    let i = 0
    let icon = config.svgIcon.replace(/<path/g, match => ++i === 2 ? `<path fill="#${config.hexColor}"` : match)
    const src = 'data:image/svg+xml;utf8,' + escape(icon)
    return {
        image: new Icon({
            opacity: 1,
            src: src,
            scale: scale,
        })
    }
}

function getDash(config){
    const dashDic =  {
        dashed: {
            lineDash: [4]
        },
        solid : {
        },
        dotted: {
            lineDash: [1, 4, 1, 4]
        },
        "dash-dotted":{
            lineDash: [9, 3, 3, 3]
        }
    }
    let dash
    if (!Array.isArray(config.stroke)){
        dash = config.stroke in dashDic ? dashDic[config.stroke]: dashDic["solid"]
    }else{
        dash = {
            lineDash: config.stroke
        }
    }
    return dash
}

function polygonStyle (config) {
    // TODO: fix default colors in generator code
    let colorString = `rgb(${config.color[0]},${config.color[1]},${config.color[2]})`
    let fillColor = `rgba(${config.color[0]},${config.color[1]},${config.color[2]},0.2)`
    if (!("stroke" in config)){
        config.stroke="dashed"
    }
    if (!("width" in config)){
        config.width=2
    }
    let dash = getDash(config)
    return {
        stroke: new Stroke(
            {
                ...{
                    color: colorString,
                    width: config.width,
                },
                ...dash
            }
        ),
        fill: new Fill({
            color: fillColor,
        }),
    }
}

function getStyle (config) {
    const styles = {
        'Point': pointStyle,
        'LineString': lineStyle,
        'Polygon': polygonStyle,
    };
    let style = styles[config.geomType]
    if ( typeof config.color === 'string' && config.color.split(',').length > 2) {
        config.color = config.color.split(',')
    }
    return style(config)
}

function getStyleFunction (config) {
    return function (feature, resolution) {
        let symbolStyle = getStyle(config)
        if ("labels" in config && config.labels) {
            const placementDic = {
                "Point": {
                    offsetX: 7,
                    offsetY: -7,
                    textAlign: 'start',
                    overflow: true
                },
                "Polygon": {
                    textAlign: 'center',
                    overflow: true
                },
                "LineString": {
                    offsetX: 6,
                    offsetY: -6,
                    textAlign: 'start',
                }
            }
            let textStyle = {
                text: new Text(
                    {
                        ...{
                            text: feature.get(config.labelProperty),
                            scale: 1.3,
                            fill: new Fill({
                                color: '#000000'
                            }),
                            stroke: new Stroke({
                                color: 'rgba(255, 255, 255, 0.8)',
                                width: 3
                            })
                        },
                        ...placementDic[config.geomType]
                    }
                )
            }
            return new Style(
                {
                    ...textStyle,
                    ...symbolStyle
                }
            )
        }
        return new Style(symbolStyle)
    }
}

function isValidHttpUrl (string) {
    let url;

    try {
        url = new URL(string);
    } catch (_) {
        return false;
    }

    return url.protocol === "http:" || url.protocol === "https:";
}


if(typeof getProjection === "function"){
  console.log('getProjection exists')
}else{
    console.log('getProjection not exists')
}

const projection = getProjection('EPSG:3857');
const projectionExtent = projection.getExtent();
const size = getWidth(projectionExtent) / 256;
const resolutions = new Array(19);
const matrixIds = new Array(19);
for (let z = 0; z < 19; ++z) {
    // generate resolutions and matrixIds arrays for this WMTS
    resolutions[z] = size / Math.pow(2, z);
    matrixIds[z] = z;
}

async function getResourceText (filename) {
    let response = await fetch(filename);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.text();
}

async function getFeatureData (config) { 
    if (config.layerType === "featureLayer"){
        let ftCollection
        if (isValidHttpUrl(config.source)){
            let ftCollectionString = await getResourceText(config.source)
            ftCollection = JSON.parse(ftCollectionString)
        }else{
            ftCollection = config.source
        }
        return {ftCollection: ftCollection, config: config}
    }else{
        // optionally retrieve metadata from service
        return {serviceUrl: config.serviceUrl, config: config}
    }
}

function postRender (evt) {
    let grayscale = evt.target.get("grayscale")
    evt.context.globalCompositeOperation = 'color'
    if (evt.context.globalCompositeOperation === 'color') {
        // operation is supported by browser
        evt.context.fillStyle = 'rgba(255,255,255,' + grayscale + ')'
        evt.context.fillRect(
            0,
            0,
            evt.context.canvas.width,
            evt.context.canvas.height
        )
    }
    evt.context.globalCompositeOperation = 'source-over'
}


const promises = [];
// service layers rendered with custom renderer
{{ #layers}}
promises.push(
    getFeatureData(
        {{{.}}}    
    )
)
{{/layers}}
const layers = [];

// resolve promises with all to maintain layer order
Promise.all(promises).then((values) => {
    values.forEach(result => {
        if (result.config.layerType === "featureLayer"){
            layers.push(new VectorLayer({
                declutter: true,
                source: new VectorSource({
                    features: new GeoJSON({ featureProjection: 'EPSG:3857' }).readFeatures(result.ftCollection),
                }),
                style: getStyleFunction(result.config),
                opacity: result.config.opacity,
            }))
        }else if (result.config.layerType === "serviceLayer"){
            if (result.config.serviceType === "WMS"){
                layers.push(new ImageLayer({
                    source: new ImageWMS({
                        url: result.config.serviceUrl,
                        params: { 'LAYERS': result.config.layerName }, // TODO: add style parameter
                        ratio: 1
                    }),
                    ...("grayscale" in result.config && {grayscale: result.config.grayscale}), // add property conditionally
                    ...("opacity" in result.config && {opacity: result.config.opacity}),
                }))
            }else if (result.config.serviceType === "WMTS"){
                layers.push(new TileLayer({
                    source: new WMTS({    
                        url: result.config.serviceUrl,
                        layer: result.config.layerName,
                        matrixSet: 'EPSG:3857',
                        format: 'image/png',
                        projection: projection,
                        tileGrid: new WMTSTileGrid({
                            origin: getTopLeft(projectionExtent),
                            resolutions: resolutions,
                            matrixIds: matrixIds,
                        }),
                        style: 'default',
                        wrapX: true,
                    }),
                    ...("grayscale" in result.config && {grayscale: result.config.grayscale}), // add property conditionally
                    ...("opacity" in result.config && {opacity: result.config.opacity}),
                }))
            }
        }
    })
    map.setLayers(layers)
    map
        .getLayers().forEach(lyr => {
            let grayscale = lyr.get('grayscale')
            if (grayscale>0){
                lyr.on('postrender', postRender)
            }
            
        }
        )
});

map.setTarget(document.getElementById('map'))
// promise returning viewOptions is expected instead of View object https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html#setView

{{#location}}
let viewConfig = {
    center: [{{ x }}, {{ y }}],
    zoom: {{ z }},
}
{{/location}}
{{^location }} //default location
let viewConfig = {
    center: [564457.4160, 6783258.6045],
    zoom: 7,
}
{{/location}}

const viewOptions = new Promise((resolve, reject) => {
    resolve(
        viewConfig
    );
});
map.setView(viewOptions)

{{#constrainBoundsEnabled }}
map.once('postrender', function(event) {   
    setTimeout(() => {
        let mapExtent = map.getView().calculateExtent(map.getSize())
        
        viewConfig.extent = mapExtent
        const viewOptions = new Promise((resolve, reject) => {
            resolve(
                viewConfig
            );
        });
        map.setView(viewOptions)
    }, 10);
});
{{/constrainBoundsEnabled }}

// enableLsControl if function is defined 
{{#lsControlEnabled}}
    enableLsControl()
{{/lsControlEnabled}}
